<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalkulator Fotowoltaiki PV</title>
    <!-- Załączamy Bootstrap 4.5 CSS z CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
    /* Drobne dostosowania stylu (ciemny motyw) */
    .card.bg-secondary {
        border-color: #444;
    }
    /* Utility classes to replace inline styles */
    .max-w-200 { max-width: 200px; }
    .max-w-120 { max-width: 120px; }
    .max-w-100 { max-width: 100px; }
    /* Ukryty input plików (przeniesiono inline style do CSS) */
    #csvFiles { display: none; }
    </style>
</head>
<body class="bg-dark text-light">
<div class="container my-4">
  <!-- Link powrotu -->
  <a href="index.html" class="btn btn-secondary btn-sm mb-3">&larr; Powrót do pulpitu</a>
  <h1 class="mb-4">Kalkulator Fotowoltaiki (PV)</h1>
  <div class="row">
    <!-- Kolumna główna z formularzem -->
    <div class="col-md-8">
      <!-- Wybór paneli -->
      <div class="form-group">
        <div class="d-flex">
          <select id="panelSelect" class="form-control mr-2" title="Wybór paneli" aria-label="Wybór paneli"></select>
          <label for="panelCount" class="sr-only">Liczba paneli</label>
          <input type="number" id="panelCount" class="form-control max-w-100" min="0" value="10" title="Liczba paneli" placeholder="10" aria-label="Liczba paneli">
          <span class="ml-2 align-self-center">szt.</span>
        </div>
      </div>
      <!-- Dobór falownika -->
      <div class="form-group">
        <label for="inverterSelect">Dobór falownika:</label>
        <select id="inverterSelect" class="form-control"></select>
      </div>
      <!-- Magazyn energii -->
      <div class="form-group">
        <label for="batterySelect">Magazyn energii (bateria):</label>
        <select id="batterySelect" class="form-control">
          <option value="none">Brak</option>
        </select>
      </div>
      <!-- Magazyn ciepła -->
      <div class="form-group">
        <label for="heatSelect">Magazyn ciepła (bufor):</label>
        <select id="heatSelect" class="form-control">
          <option value="none">Brak</option>
        </select>
      </div>
      <!-- Rodzaj montażu i odległość -->
      <div class="form-group">
        <label for="mountSelect">Rodzaj montażu:</label>
        <div class="d-flex">
          <select id="mountSelect" class="form-control mr-3">
            <option value="pitched">Dach skośny</option>
            <option value="flat">Dach płaski</option>
            <option value="ground">Grunt</option>
          </select>
          <div>
            <label for="distanceInput" class="sr-only">Odległość (m)</label>
            <div class="input-group">
              <input type="number" id="distanceInput" class="form-control" min="0" value="20">
              <div class="input-group-append">
                <span class="input-group-text">m (odległość paneli od falownika)</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Dodatkowe opcje (checkboxy) -->
      <div class="form-group">
        <label>Dodatkowe opcje:</label>
        <div class="form-check">
          <input type="checkbox" id="optCheck" class="form-check-input">
          <label for="optCheck" class="form-check-label">Optymalizatory na panelach</label>
        </div>
        <div class="form-check">
          <input type="checkbox" id="meterCheck" class="form-check-input">
          <label for="meterCheck" class="form-check-label">Licznik produkcji energii</label>
        </div>
        <div class="form-check">
          <input type="checkbox" id="boardCheck" class="form-check-input">
          <label for="boardCheck" class="form-check-label">Dodatkowa rozdzielnia/przyłącze</label>
        </div>
      </div>
      <div class="form-group">
        <label for="investorSelect">Typ inwestora i VAT:</label>
        <div class="d-flex">
          <select id="investorSelect" class="form-control mr-3 max-w-200" title="Typ inwestora">
            <option value="private">Osoba prywatna</option>
            <option value="company">Firma (płatnik VAT)</option>
          </select>
          <label for="areaInput" class="sr-only">Powierzchnia (m²)</label>
          <input type="number" id="areaInput" class="form-control mr-3 max-w-120" title="Powierzchnia nieruchomości" placeholder="120" value="120" min="1">
          <span class="align-self-center mr-3">m&sup2;</span>
          <label for="commissionInput" class="align-self-center mr-2">Prowizja:</label>
          <div class="input-group max-w-120">
            <input type="number" id="commissionInput" class="form-control" value="0" min="0" step="0.1" title="Prowizja w procentach">
            <div class="input-group-append"><span class="input-group-text">%</span></div>
          </div>
          <small class="form-text text-muted">
            * 8% VAT dla budownictwa mieszkaniowego (dom &le;300 m&sup2;), w przeciwnym razie 23%.
          </small>
        </div>
      </div>
      <!-- Przyciski akcji -->
      <div class="form-group mt-4">
        <button id="loadBtn" class="btn btn-info">Załaduj z CSV</button>
        <button id="resetBtn" class="btn btn-secondary">Resetuj kalkulator</button>
        <button class="btn btn-light" onclick="window.print()">Drukuj</button>
      </div>
      <!-- Ukryte pole plików do wczytywania CSV -->
      <input type="file" id="csvFiles" accept=".csv" multiple>
    </div>
    <!-- Kolumna boczna z podsumowaniem -->
    <div class="col-md-4">
      <div class="card bg-secondary text-light p-3">
        <h5>Podsumowanie:</h5>
        <table class="table table-borderless table-sm text-light">
          <tr><td>Moc zestawu PV:</td><td id="pvPowerVal">0 kWp</td></tr>
          <tr><td>Wartość netto (bez prowizji):</td><td id="netBaseVal">0 zł</td></tr>
          <tr><td>Prowizja handlowca:</td><td id="commissionVal">0 zł</td></tr>
          <tr><td>Wartość netto (z prowizją):</td><td id="netTotalVal">0 zł</td></tr>
          <tr><td>VAT (<span id="vatRateVal">8</span>%):</td><td id="vatVal">0 zł</td></tr>
          <tr><td><strong>Wartość brutto:</strong></td><td id="grossVal"><strong>0 zł</strong></td></tr>
          <tr><td>Dotacja Mój Prąd 6.0:</td><td id="subsidyVal">0 zł</td></tr>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
// Tablice danych z CSV
let panelsData = [], invertersData = [], batteriesData = [], heatData = [], extrasData = [];
// Ceny/dane dodatkowe
let optimizerPrice = 0, meterPrice = 0, boardPrice = 0, trenchPrice = 0;
let extraCablePrice = 50; // 50 zł/m powyżej 20 m
let structureCosts = { pitched: 0, flat: 0, ground: 0 };
// Funkcja parsująca CSV do obiektów JS
function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (!lines.length) return [];
    // Wykrycie delimitera (przecinek lub średnik)
    const delim = lines[0].includes(';') ? ';' : ',';
    const header = lines[0].split(delim).map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        let line = lines[i];
        if (!line.trim()) continue;
        // Jeżeli delimiter to przecinek, a liczby używają przecinka dziesiętnego, poprawiamy je przed split
        if (delim === ',' && /\d,\d{1,2}(?![^"]*")/.test(line)) {
            line = line.replace(/(\d),(\d{1,2})(?![^"]*")/g, '$1.$2');
        }
        let parts = line.split(delim).map(p => p.trim());
        // Dopasowanie liczby kolumn do nagłówka
        if (parts.length !== header.length) {
            const filtered = [];
            for (let part of parts) {
                if (part === 'PLN' || part.toLowerCase() === 'pln' || part === 'zł' || part === '') continue;
                filtered.push(part);
            }
            if (filtered.length === header.length + 1) {
                filtered.shift(); // usuń ewentualny kod towaru jeśli jest nadmiarowy
            }
            while (filtered.length > header.length) {
                // łączenie nadmiarowych kolumn na końcu
                filtered[filtered.length-2] += ' ' + filtered[filtered.length-1];
                filtered.pop();
            }
            while (filtered.length < header.length) {
                filtered.push('');
            }
            parts = filtered;
        }
        const obj = {};
        for (let j = 0; j < header.length; j++) {
            const key = header[j] ? header[j].trim() : 'Field'+j;
            let val = j < parts.length ? parts[j] : '';
            if (val.startsWith('"') && val.endsWith('"')) {
                val = val.slice(1, -1);
            }
            // Konwersja wartości numerycznych dla określonych pól
            const keyLower = key.toLowerCase();
            if (keyLower.includes('cena') || keyLower.includes('price') || keyLower.includes('cost')) {
                let num = parseFloat(val.replace(/,/g, '.').replace(/[^0-9.\-]+/g, ''));
                obj[key] = isNaN(num) ? val : num;
            } else if (keyLower.includes('moc') || keyLower.includes('power') || keyLower.includes('pojemność') || keyLower.includes('capacity')) {
                let num = parseFloat(val.replace(/,/g, '.'));
                obj[key] = isNaN(num) ? val : (Number.isInteger(num) ? Number(num) : num);
            } else {
                obj[key] = val;
            }
        }
        data.push(obj);
    }
    return data;
}
// Pomocnicza funkcja pobierająca wartość z obiektu po polskiej lub angielskiej nazwie pola
function getVal(obj, keys) {
    for (let k of keys) {
        if (obj.hasOwnProperty(k)) return obj[k];
        // Sprawdź bez rozróżniania wielkości liter
        for (let ok in obj) {
            if (ok.toLowerCase() === k.toLowerCase()) {
                return obj[ok];
            }
        }
    }
    return undefined;
}
// Sprawdzenie, czy dany falownik jest hybrydowy (po nazwie lub typie)
function isHybridInverter(invObj) {
    let type = getVal(invObj, ['Typ','Type','Rodzaj']);
    if (type && typeof type === 'string') {
        if (type.toLowerCase().includes('hyb')) return true;
    }
    let name = getVal(invObj, ['Nazwa','Name']);
    if (name && typeof name === 'string') {
        return name.toLowerCase().includes('hyb');
    }
    return false;
}
// Wypełnienie list wyboru danymi
function populateOptions() {
    // Panele PV
    const panelSelect = document.getElementById('panelSelect');
    panelSelect.innerHTML = '';
    panelsData.forEach((panel, idx) => {
        const name = getVal(panel, ['Nazwa','Name']) || `Panel ${idx+1}`;
        const power = getVal(panel, ['Moc','Power']) || 0;
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = name + (power ? ` - ${power} W` : '');
        panelSelect.appendChild(opt);
    });
    // Falowniki
    const inverterSelect = document.getElementById('inverterSelect');
    inverterSelect.innerHTML = '<option value="none">Brak</option>';
    invertersData.forEach((inv, idx) => {
        const name = getVal(inv, ['Nazwa','Name']) || `Falownik ${idx+1}`;
        const power = getVal(inv, ['Moc','Power']) || 0;
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = name + (power ? ` - ${power} kW` : '');
        if (isHybridInverter(inv)) {
            opt.textContent += ' (hybrydowy)';
            opt.dataset.hybrid = '1';
        } else {
            opt.dataset.hybrid = '0';
        }
        inverterSelect.appendChild(opt);
    });
    // Baterie
    const batterySelect = document.getElementById('batterySelect');
    // Zachowujemy opcję "Brak", potem dodajemy resztę
    batteriesData.forEach((bat, idx) => {
        const name = getVal(bat, ['Nazwa','Name']) || `Bateria ${idx+1}`;
        const cap = getVal(bat, ['Pojemność','Capacity','kWh','KWh','Moc','Power']);
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = name + (cap ? ` - ${cap} kWh` : '');
        batterySelect.appendChild(opt);
    });
    // Bufory ciepła
    const heatSelect = document.getElementById('heatSelect');
    heatData.forEach((heat, idx) => {
        const name = getVal(heat, ['Nazwa','Name']) || `Magazyn ${idx+1}`;
        const vol = getVal(heat, ['Pojemność','Capacity','Volume','Objętość','Moc','Power']);
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = name + (vol ? ` - ${vol} l` : '');
        heatSelect.appendChild(opt);
    });
}
// Przeliczenie wartości podsumowania
function recalc() {
    const panelSelect = document.getElementById('panelSelect');
    const panelCountInput = document.getElementById('panelCount');
    const inverterSelect = document.getElementById('inverterSelect');
    const batterySelect = document.getElementById('batterySelect');
    const heatSelect = document.getElementById('heatSelect');
    const mountSelect = document.getElementById('mountSelect');
    const distanceInput = document.getElementById('distanceInput');
    const optCheck = document.getElementById('optCheck');
    const meterCheck = document.getElementById('meterCheck');
    const boardCheck = document.getElementById('boardCheck');
    const investorSelect = document.getElementById('investorSelect');
    const areaInput = document.getElementById('areaInput');
    const commissionInput = document.getElementById('commissionInput');
    // Odczyt aktualnych wartości
    const panelIdx = parseInt(panelSelect.value);
    const panelCount = Math.max(0, parseInt(panelCountInput.value) || 0);
    const panelPower = (panelIdx >= 0 && panelIdx < panelsData.length) 
                       ? (getVal(panelsData[panelIdx], ['Moc','Power']) || 0) 
                       : 0;
    // Moc zestawu w kW
    const pvPowerKW = (panelPower * panelCount) / 1000;
    // Automatyczny dobór falownika
    let selectedInverterIdx = inverterSelect.value;
    if (panelCount > 0) {
        const needHybrid = (batterySelect.value !== 'none');
        let bestIdx = null;
        let bestPower = null;
        invertersData.forEach((inv, idx) => {
            const invPower = getVal(inv, ['Moc','Power']) || 0;
            const invHybrid = isHybridInverter(inv);
            if (needHybrid && !invHybrid) return;
            if (!needHybrid && invHybrid) return;
            if (pvPowerKW <= invPower + 1e-3) {  // >= moc paneli
                if (bestIdx === null || invPower < bestPower) {
                    bestIdx = idx;
                    bestPower = invPower;
                }
            }
        });
        if (bestIdx === null && invertersData.length > 0) {
            // Jeśli brak falownika o mocy >= PV, wybierz najmocniejszy dostępny
            bestIdx = 0;
            bestPower = getVal(invertersData[0], ['Moc','Power']) || 0;
            for (let idx = 1; idx < invertersData.length; idx++) {
                const invPower = getVal(invertersData[idx], ['Moc','Power']) || 0;
                const invHybrid = isHybridInverter(invertersData[idx]);
                if (needHybrid && !invHybrid) continue;
                if (!needHybrid && invHybrid) continue;
                if (invPower > bestPower) {
                    bestIdx = idx;
                    bestPower = invPower;
                }
            }
        }
        if (bestIdx !== null) {
            selectedInverterIdx = String(bestIdx);
            inverterSelect.value = selectedInverterIdx;
        }
        // Jeśli przypadkowo było ustawione "Brak", a mamy panele, to ustaw automatycznie dobrany
        if (inverterSelect.value === 'none') {
            inverterSelect.value = selectedInverterIdx;
        }
    } else {
        // Brak paneli -> brak nowego falownika
        inverterSelect.value = 'none';
        selectedInverterIdx = 'none';
    }
    // Kalkulacja kosztów
    let netBase = 0;
    // Koszt paneli
    if (panelCount > 0 && panelIdx >= 0 && panelIdx < panelsData.length) {
        const panelPrice = getVal(panelsData[panelIdx], ['Cena','Price']) || 0;
        netBase += panelPrice * panelCount;
    }
    // Koszt falownika
    if (selectedInverterIdx !== 'none') {
        const idx = parseInt(selectedInverterIdx);
        if (!isNaN(idx) && idx >= 0 && idx < invertersData.length) {
            const invPrice = getVal(invertersData[idx], ['Cena','Price']) || 0;
            netBase += invPrice;
        }
    }
    // Koszt baterii
    let hasBattery = false;
    if (batterySelect.value !== 'none') {
        const bIdx = parseInt(batterySelect.value);
        if (!isNaN(bIdx) && bIdx >= 0 && bIdx < batteriesData.length) {
            const batPrice = getVal(batteriesData[bIdx], ['Cena','Price']) || 0;
            netBase += batPrice;
            hasBattery = true;
        }
    }
    // Koszt magazynu ciepła
    let hasHeat = false;
    if (heatSelect.value !== 'none') {
        const hIdx = parseInt(heatSelect.value);
        if (!isNaN(hIdx) && hIdx >= 0 && hIdx < heatData.length) {
            const heatPrice = getVal(heatData[hIdx], ['Cena','Price']) || 0;
            netBase += heatPrice;
            hasHeat = true;
        }
    }
    // Koszt konstrukcji montażowej
    const mountType = mountSelect.value;
    if (mountType && structureCosts[mountType] && panelCount > 0) {
        netBase += structureCosts[mountType] * panelCount;
    }
    // Koszt przekopu (jeśli grunt)
    if (mountType === 'ground') {
        netBase += trenchPrice;
    }
    // Dodatkowy kabel
    const distance = parseFloat(distanceInput.value) || 0;
    if (distance > 20) {
        netBase += (distance - 20) * extraCablePrice;
    }
    // Optymalizatory
    if (optCheck.checked && panelCount > 0) {
        netBase += optimizerPrice * panelCount;
    }
    // Licznik
    if (meterCheck.checked) {
        netBase += meterPrice;
    }
    // Rozdzielnia
    if (boardCheck.checked) {
        netBase += boardPrice;
    }
    // Prowizja
    const commissionRate = parseFloat(commissionInput.value) || 0;
    const commissionAmount = netBase * (commissionRate / 100.0);
    const netWithComm = netBase + commissionAmount;
    // VAT
    let vatRate = 23;
    if (investorSelect.value === 'private') {
        const area = parseFloat(areaInput.value) || 0;
        if (area <= 300) {
            vatRate = 8;
        } else {
            vatRate = 23;
        }
    }
    const vatAmount = netWithComm * (vatRate / 100.0);
    const gross = netWithComm + vatAmount;
    // Dotacja Mój Prąd 6.0
    let subsidy = 0;
    if (panelCount > 0 || hasBattery || hasHeat) {
        if (panelCount > 0) {
            if (hasBattery && hasHeat) {
                subsidy = 7000 + 16000 + 5000;
            } else if (hasBattery) {
                subsidy = 7000 + 16000;
            } else if (hasHeat) {
                subsidy = 7000 + 5000;
            } else {
                subsidy = 0; // PV bez magazynu (po 1.08.2024 brak dotacji)
            }
        } else {
            if (hasBattery && hasHeat) {
                subsidy = 16000 + 5000;
            } else if (hasBattery) {
                subsidy = 16000;
            } else if (hasHeat) {
                subsidy = 5000;
            }
        }
        const maxByCost = 0.5 * netBase;
        if (subsidy > maxByCost) {
            subsidy = maxByCost;
        }
        subsidy = Math.floor(subsidy);
    }
    // Wyświetlenie wyników
    document.getElementById('pvPowerVal').textContent = pvPowerKW.toLocaleString('pl-PL', {minimumFractionDigits: 2, maximumFractionDigits: 2}) + ' kWp';
    document.getElementById('netBaseVal').textContent = netBase.toLocaleString('pl-PL', {style: 'currency', currency: 'PLN'});
    document.getElementById('commissionVal').textContent = commissionAmount.toLocaleString('pl-PL', {style: 'currency', currency: 'PLN'});
    document.getElementById('netTotalVal').textContent = netWithComm.toLocaleString('pl-PL', {style: 'currency', currency: 'PLN'});
    document.getElementById('vatRateVal').textContent = vatRate;
    document.getElementById('vatVal').textContent = vatAmount.toLocaleString('pl-PL', {style: 'currency', currency: 'PLN'});
    document.getElementById('grossVal').textContent = gross.toLocaleString('pl-PL', {style: 'currency', currency: 'PLN'});
    document.getElementById('subsidyVal').textContent = subsidy.toLocaleString('pl-PL', {style: 'currency', currency: 'PLN'});
}
// Nasłuchiwanie zmian na polach formularza
document.getElementById('panelSelect').addEventListener('change', recalc);
document.getElementById('panelCount').addEventListener('input', recalc);
document.getElementById('inverterSelect').addEventListener('change', recalc);
document.getElementById('batterySelect').addEventListener('change', recalc);
document.getElementById('heatSelect').addEventListener('change', recalc);
document.getElementById('mountSelect').addEventListener('change', recalc);
document.getElementById('distanceInput').addEventListener('input', recalc);
document.getElementById('optCheck').addEventListener('change', recalc);
document.getElementById('meterCheck').addEventListener('change', recalc);
document.getElementById('boardCheck').addEventListener('change', recalc);
document.getElementById('investorSelect').addEventListener('change', recalc);
document.getElementById('areaInput').addEventListener('input', recalc);
document.getElementById('commissionInput').addEventListener('input', recalc);
// Funkcja wczytująca wszystkie CSV przez fetch
async function loadAllCSVs() {
    try {
        const panelRes    = await fetch('panele.csv');
        const inverterRes = await fetch('inwertery.csv');
        const batteryRes  = await fetch('baterie.csv');
        const heatRes     = await fetch('magazyny_ciepla.csv');
        const extrasRes   = await fetch('dodatki.csv');
        if (!panelRes.ok) throw new Error('CSV not found');
        const panelText    = await panelRes.text();
        const inverterText = await inverterRes.text();
        const batteryText  = await batteryRes.text();
        const heatText     = await heatRes.text();
        const extrasText   = await extrasRes.text();
        panelsData    = parseCSV(panelText);
        invertersData = parseCSV(inverterText);
        batteriesData = parseCSV(batteryText);
        heatData      = parseCSV(heatText);
        extrasData    = parseCSV(extrasText);
        processExtrasData();
        populateOptions();
        recalc();
    } catch (err) {
        console.warn('Automatyczne wczytanie CSV nie powiodło się:', err);
        alert('Nie udało się załadować danych CSV. Proszę użyć przycisku "Załaduj z CSV" i wybrać pliki ręcznie.');
    }
}
// Przetworzenie danych z pliku "dodatki"
function processExtrasData() {
    optimizerPrice = meterPrice = boardPrice = trenchPrice = 0;
    structureCosts.pitched = structureCosts.flat = structureCosts.ground = 0;
    extraCablePrice = 50;
    extrasData.forEach(item => {
        const name = (getVal(item, ['Nazwa','Name']) || '').toLowerCase();
        const price = getVal(item, ['Cena','Price']) || 0;
        if (name.includes('optym')) {
            optimizerPrice = price;
        } else if (name.includes('licznik')) {
            meterPrice = price;
        } else if (name.includes('rozdziel')) {
            boardPrice = price;
        } else if (name.includes('przekop')) {
            trenchPrice = price;
        } else if (name.includes('kabel') || name.includes('odległość') || name.includes('odleglosc')) {
            extraCablePrice = price;
        } else if (name.includes('skoś') || name.includes('skos')) {
            structureCosts.pitched = price;
        } else if (name.includes('płask') || name.includes('plask')) {
            structureCosts.flat = price;
        } else if (name.includes('grunt')) {
            structureCosts.ground = price;
        }
    });
    // Jeśli brak cen konstrukcji w CSV, pozostają domyślnie 0 (można ustawić default)
    // if (!structureCosts.pitched) structureCosts.pitched = 0;
    // if (!structureCosts.flat) structureCosts.flat = 0;
    // if (!structureCosts.ground) structureCosts.ground = 0;
}
// Obsługa ręcznego wyboru plików CSV
document.getElementById('csvFiles').addEventListener('change', event => {
    const files = event.target.files;
    if (!files || files.length === 0) return;
    const fileMap = { panele: null, inwertery: null, baterie: null, magazyny: null, dodatki: null };
    for (let f of files) {
        const fname = f.name.toLowerCase();
        if (fname.includes('panel')) fileMap.panele = f;
        else if (fname.includes('inwer')) fileMap.inwertery = f;
        else if (fname.includes('bater')) fileMap.baterie = f;
        else if (fname.includes('ciep') || fname.includes('heat')) fileMap.magazyny = f;
        else if (fname.includes('dodat') || fname.includes('extra')) fileMap.dodatki = f;
    }
    const readerPromises = [];
    for (let key in fileMap) {
        if (fileMap[key]) {
            readerPromises.push(new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onerror = () => reject(reader.error);
                reader.onload = () => resolve({ key: key, text: reader.result });
                reader.readAsText(fileMap[key]);
            }));
        }
    }
    Promise.all(readerPromises).then(results => {
        results.forEach(({key, text}) => {
            const data = parseCSV(text);
            if (key === 'panele') panelsData = data;
            if (key === 'inwertery') invertersData = data;
            if (key === 'baterie') batteriesData = data;
            if (key === 'magazyny') heatData = data;
            if (key === 'dodatki') extrasData = data;
        });
        processExtrasData();
        populateOptions();
        recalc();
    }).catch(err => {
        alert('Błąd podczas wczytywania plików CSV: ' + err);
    });
});
// Podpięcie akcji przycisków
document.getElementById('loadBtn').addEventListener('click', () => {
    document.getElementById('csvFiles').click();
});
document.getElementById('resetBtn').addEventListener('click', () => {
    document.getElementById('panelSelect').selectedIndex = 0;
    document.getElementById('panelCount').value = 10;
    document.getElementById('batterySelect').value = 'none';
    document.getElementById('heatSelect').value = 'none';
    document.getElementById('mountSelect').value = 'pitched';
    document.getElementById('distanceInput').value = 20;
    document.getElementById('optCheck').checked = false;
    document.getElementById('meterCheck').checked = false;
    document.getElementById('boardCheck').checked = false;
    document.getElementById('investorSelect').value = 'private';
    document.getElementById('areaInput').value = 120;
    document.getElementById('commissionInput').value = 0;
    recalc();
});
window.addEventListener('load', () => {
    loadAllCSVs();
});
</script>
</body>
</html>
